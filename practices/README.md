# 쿠버네티스
- 쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식할 수 있고, 확장 가능한 오픈소스 플랫폼으로, 선언적 구성과 자동화를 모두 지원한다.
- 쿠버네티스의 기능
    - 서비스 디스커버리와 로드 밸런싱
        - 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다.
        - 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.
    - 스토리지 오케스트레이션
        - 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있다.
    - 자동화된 롤아웃과 롤백
        - 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다.
    - 자동화된 빈 패킹 (bin packing)
        - 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다.
        - 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
    - 자동화된 복구 (self-healing)
        - 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.
    - 시크릿과 구성 관리
        - 쿠버네티스를 사용하면 암호, OAut 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있다.
    - 배치 실행
        - 서비스 외에도, 쿠버네티스는 배치 및 CI 워크로드를 관리할 수 있으며, 필요한 경우 실패한 컨테이너를 교체할 수 있다.
    - 수평 확장
        - 간단한 명령어, UI또는 CPU 사용량에 따라 자동으로 애플리케이션을 확장하거나 축소할 수 있다.
    - 확장성을 고려한 설계
        - 업스트림 소스 코드를 변경하지 않고 쿠버네티스 클러스터 기능을 추가할 수 있다.


## 쿠버네티스 컴포넌트
- 핵심 컴포넌트
    - 쿠버네티스 클러스터는 컨트롤 플레인과 하나 이상의 워커 노드로 구성된다.
    - 컨트롤 플레인 컨포넌트
        - 클러스터 전체 상태를 관리한다.
- 노드 컴포넌트
    - 모든 노드에서 실행되며, 실행 중인 파드를 유지하고 쿠버네티스 런타임 환경을 제공한다.
- 애드온
    - 애드온은 쿠버네티스 기능을 확장한다.


## 쿠버네티스 API
- 쿠버네티스 API를 사용하면 쿠버네티스 오브젝트들의 상태를 쿼리하고 조작할 수 있다.

---

## 쿠버네티스 오브젝트
- 쿠버네티스 오브젝트는 쿠버네티스 시스템에서 영속성을 가지는 오브젝트이다.
    - 어떤 컨테이너화된 애플리케이션이 동작 중인지 (그리고 어느 노드에서 동작 중인지)
    - 그 애플리케이션이 이용할 수 있는 리소스
    - 그 애플리케이션이 어떻게 재구동 정책, 업그레이드, 그리고 내고장성과 같은 것에 동작해야 하는지에 대한 정책

### 오브젝트 명세(spec)와 상태(status)
- 거의 모든 쿠버네티스 오브젝트는 오브젝트의 구성을 결정해주는 두 개의 중첩된 오브젝트 필드를 포함하는데 `spec`과 `status`이다.
    - `spec`을 가진 오브젝트는 오브젝트를 생성할 때 리소스에 원하는 상태에 대한 설명을 제공해서 설정한다.
    - `status`는 쿠버네티스 시스템과 컴포넌트에 의해 제공되고 업데이트된 오브젝트의 현재 상태를 설명한다.

### 쿠버네티스 오브젝트 기술하기
- 쿠버네티스에서 오브젝트를 생성 할 때, 오브젝트에 대한 기본적인 정보와 더불어, 의도한 상태를 기술한 오브젝트 spec을 제시해 줘야만 한다. 오브젝트를 생성하기 위해 쿠버네티스 API 를 이용할 때, API 요청은 요청 내용 안에 JSON 형식으로 정보를 포함시켜 줘야만 한다. 대부분의 경우 정보를 .yaml 파일로 kubectl 에 제공한다. kubectl 은 API 요청이 이루어질 때, JSON 형식으로 정보를 변환시켜 준다.


## 쿠버네티스 오브젝트 관리
### 명령형 커맨드
- `kubectl create [resource] [OPTIONS]`
- 사용자가 `kubectl`의 하위 명령어와 플래그를 통해 수행할 작업을 직접 지정하는 방식이다. 이 과정에서 완전한 오브젵그 명세 파일은 사용되지 않는다.

- 동작 원리
    - kubectl 클라이언트는 사용자의 명령어와 플래그를 기반으로 API 서버에 전송할 오브젝트 명세를 메모리상에서 구성한다.
    - 구성된 명세를 바탕으로 API 서버에 적절한 HTTP 요청 (`POST : /apis/apps/v1/namespaces/default/deployments`)을 보냅니다.
    - `kubectl scale`이나 `kubectl edit` 같은 명령어는 기존 오브젝트를 수정ㅇ하기 위해 `GET`으로 현재 상태를 가져온 후, 변경 사항을 계산하여 `PATCH` 또는 `PUT` 요청을 보낸다.


### 명령형 오브젝트 구성
- `kubectl create -f [FILE_NAME]`
- 사전에 작성된 완전한 오브젝트 명세 파일(yaml, json)을 사용하여 create, replace, delete와 같은 명시적인 작업을 지시하는 방식이다.

- 동작 원리
    - `kubectl create -f <filename>`
        - 명세 파일을 API 서버에 POST 요청으로 보내 오브젝스 생성을 시도한다. 동일한 이름의 오브젝트가 이미 존재하면 HTTP 409 Conflict 에러를 반환하며 실패한다.
    - `kubectl replace -f <filename>`
        - 기존 오브젝트를 완전히 교체하기 위해 PUT 요청을 사용한다. 이 과정은 먼저 GET으로 최신 리소스 버전을 확인한 후, 제공된 명세 파일의 내용으로 기존 명세를 덮어 쓴다. 이는 파괴적인 업데이트이며, 서비스 중단을 유발할 수 있다.
    - `kubectl delete -f <filename>`
        - 명세 파일에 명시된 이름과 종류를 가진 오브젝트에 DELETE 요청을 보낸다.


### 선언형 오브젝트 구성
- `kubectl apply -f [FILE_NAME]`
- 오브젝트 명세 파일을 '원한는 상태'로 선언하고, `kubectl apply` 명령어를 통해 현재 클러스터의 상태를 이 '원하는 상태'와 일치하도록 조정하는 방식이다.

- 동작 원리
    - `kubectl apply -f <filename>` 은 대상 오브젝트가 존재하는지 먼저 확인한다.
    - 오브젝트가 없을 경우
        - create와 동일하게 POST 요청을 보내 오브젝트를 생성한다.
    - 오브젝트가 있을 경우
        1. `apply`는 라이브 오브젝트의 metadata.annotaions에 저장된 `kubectl.kubernetes.io/last-applied-configuration` 어노테이션 (이전 apply 시점의 명세)을 읽는다.
        2. `이전 명세`, `현재 라이블 상태`, `새로운 명세 파일` 이 세 가지를 비교하는 `3-way-merge` 전략을 사용하여 변경이 필요한 부분만 계산한다.
        3. 계산된 변경 사항을 `JSON patch` 형태로 만들어 API 서버에 PATCH 요청을 보낸다. 이는 최소한의 변경만을 적용하는 비파괴적인 업데이트이다.
        4. 이 과정에서 서비스의 `clusterIP`처럼 클러스터가 자동으로 할당한 필드들은 유지된다.


## 오브젝트 이름과 ID
- 클러스터의 각 오브젝트는 해당 유형의 리소스에 대하여 고유한 이름을 가지고 있다. 또한, 모든 쿠버네티스 오브젝트는 전체 클러스터에 걸쳐 고유한 UID를 가지고 있다.
- 네임스페이스 내에서는 이름이 동일한 파드는 존재할 수 없지만 이름이 동일한 파드와 디플로이먼트는 각각 존재 가능하다.
- 유일하지 않은 사용자 제공 속성의 경우 쿠버네티스는 `레이블`과 `어노테이션`을 제공한다.

### 이름
- `/api/v1/pods/some-name`과 같이, 리소스 URL에서 오브젝트를 가리키는 클라이언트 제공 문자열
- 특정 시점에 같은 종류(kind) 내에서는 하나의 이름은 하나의 오브젝트에만 지정될 수 있다. 하지만, 오브젝트를 삭제한 경우, 삭제된 오브젝트와 같은 이름을 새로운 오브젝트에 지정 가능하다.
- 리소스에는 일반적으로 사용되는 네가지 유형의 이름 제한 조건이 있다.
    - DNS 서브도메인 이름
    - RFC 1123 레이블 이름
    - RFC 1035 레이블 이름
    - 경로 세그먼트 이름

### UID
- 오브젝트를 중복 없이 식별하기 위해 쿠버네티스 시스템이 생성하는 문자열
- 쿠버네티스 클러스터가 구동되는 전체 시간에 걸쳐 생성되는 모든 오브젝트는 서로 구분 되는 UID를 갖는다. 이는 기록상 유사한 오브젝트의 출현을 서로 구분하기 위함이다.


## 레이블과 셀렉터
- 레이블은 파드와 같은 오브젝트에 첨부된 키와 값의 쌍이다 레이블은 오브젝트의 특성을 식별하는 데 사용되어 사용자에게 중요하지만, 코어 시스템에 직접적인 의미는 없다.
- 레이블로 오브젝트의 하위 집합을 선택하고, 구성하는데 사용할 수 있다. 레이블은 오브젝트를 생성할 때에 붙이거나 생성 이후에 붙이거나 언제든지 수정이 가능하다.
- 오브젝트마다 키와 값으로 레이블을 정의할 수 있다. 오브젝트의 키는 고유한 값이어야 한다.

~~~yaml
metadata: 
    labels: 
        key1: value1
        key2: value2
~~~

### 레이블 셀렉터
- 레이블 셀렉터를 통해 클라이언트와 사용자는 오브젝트를 식별할 수 있다. 레이블 셀렉터는 쿠버네티스 코어 그룹의 기본이다.

#### 일치성 기준 요건 / 등식 기반 요건 
- 가장 간단하고 흔하게 사용되는 방식으로, 레이블의 키와 값이 정확히 일치하는지 확인한다.
- 문법
    - `key=value` : 키와 값이 모두 일치하는 리소스를 선택한다.
    - `key!=value` : 키는 일치하지만 값이 일치하지 않는 리소스를 선택한다.

~~~yaml
selector:
  matchLabels:
    app: my-app
    tier: fronted

# kubectl get pods -l app=my-sqpp,tier=frontent
~~~

#### 집합 기반 요건
- 등식 기반 보다 더 표현력이 풍부한 방식으로, 값의 집합에 포함되는지 여부나 키의 존재 여부를 기준으로 선택한다.
- 연잔자
    - `in` : values 배열에 명시된 값들 중 하나라도 일치하면 선택한다. (OR 연산)
    - `notin` : values 배열에 명시된 값들 중 하나도 일치하지 않으면 선택한다.
    - `exists` : 명시된 key를 가진 레이블이 존재하기만 하면 선택한다. (값은 확인하지 않음)
    - `doesnotexist` : 명시된 key를 가진 레이블이 존재하지 않으면 선택한다.
    - 논리 연산 : `matchExpressions` 배열 안에 여러 표현식을 명시하면, 모든 표현식을 만족해야 하는 AND 연산으로 동작한다.

~~~yaml
selector:
  matchExpressions:
    - {key: tier, operator: In, value: [frontend, backend]}
    - {key: environment, operator: NotIn, values: [dev]}
    - {key: customer, operator: Exists}
~~~
- 위 셀렉터는 다음 세 가지 조건을 모두 만족하는 파드를 선택한다.
    1. tier 레이블의 값이 frontend 또는 backend 중 하니이고,
    2. environment 레이블의 값이 dev가 아니며,
    3. customer 라는 키를 가진 레이블이 존재 하는 오브젝트
- `kubectl get pods -l 'tier in (frontend, backend),environment notin (dev),customer'`


## 네임스페이스
- 쿠버네티스에서, 네임스페이스는 단일 클러스터 내에서의 리소스 그룹 격리 메커니즘을 제공한다. 리소스의 이름은 네임스페이스 내에서 유일해야 하며, 네임스페이즈 간에서 유일할 필요는 없다. 네임스페이스 기반 스코핑은 네임스페이스 기반 오브젝트(deplyment, service 등)에만 적용 가능하며 클러스터 범위에 오브젝트(storageClass, Node, persistentVolume 등)에는 적용 불가능하다.

### 여러개의 네임스페이스를 사용하는 경우
- 네임스페이스는 여러 개의 팀이나, 프로젝트에 걸쳐서 많은 사용자가 있는 환경에서 사용하도록 만들어졌다.
- 네임스페이스는 클러스터 자원을 여러 사용자 사이에서 나누는 방법이다 
- 동일한 소프트웨어의 다른 버전과 같이 약간 다른 리소스를 분리하기 위해 여러 네임스페이스를 사용할 필요는 없다. 동일한 네임스페이스 내에서 리소스를 구별하기 위해 레이블을 사용한다.

#### 초기 네임스페이스
- 쿠버네티스는 처음에 네 개의 초기 네임스페이스를 갖는다.

- default
    - 쿠버네티스에는 이 네임스페이스가 포함되어 있으므로 먼저 네임스페이스를 생성하지 않고도 새 클러스터를 사용할 수 있다.
- kube-node-lease
    - 이 네임스페이스는 각 노드와 연관된 리스 오브젝트를 갖는다. 노드 리스는 kubelet이 하트비트를 보내서 컨트롤 플레인이 노드의 장애를 탐지할 수 있게 한다.
- kube-public
    - 이 네임스페이스는 모든 클라이언트(인증되지 않은 클라이언트 포함)가 읽기 권한으로 접근할 수 있다. 이 네임스페이스는 주로 전체 클러스터 중에 공개적으로 드러나서 읽을 수 있는 리소스를 위해 예약되어 있다.
    - 이 네임스페이스의 공개적인 성격은 단지 관례이지 요구사항은 아니다.
- kube-system
    - 쿠버네티스 시스템에서 생성한 오브젝트를 위한 네임스페이스

### 네임스페이스 다루기
- 네임스페이스 조회
    - `kubectl get namespace`

- 요청에 네임스페이스 설정하기
    - 현재 요청에 대한 네임스페이스를 설정하기 위해서 `--namespace` 플래그를 사용한다.
    - `kubectl get pods --namespace=<namespace-name>`

- 선호하는 네임스페이스 설정하기
    - 이후 kubectl 명령에서 사용하는 네임스페이스를 컨텍스트에 영구적으로 저장할 수 있다.
    - `kubectl config set-context -- current --namespace=<namespace-name>`
    - `kubectl config view --minify`

### 네임스페이스와 DNS
- 서비스를 생성하면 해당 DNS 엔트리가 생성된다. 이 엔트리는 `<service-name>.<namespace-name>.svc.cluster.local`의 형식을 갖는데, 이는 컨테이너가 `<service-name>`만 사용하는 경우, 네임스페이스 내에 국한된 서비스로 연결된다.

### 모든 오브젝트가 네임스페이스에 속하지는 않음
- 대부분의 쿠버네티스 리소스는 네임스페이스에 속한다. 하지만 네임스페이스 리소스 자체는 네임스페이스에 속하지 않는다. 그리고 노드나 퍼시스턴트 볼륨과 같은 저수준 리소스는 어느 네임스페이스에도 속하지 않는다
- `kubectl api-resources --namespaced=true`
- `kubectl api-resources --namespaced=false`


## 어노테이션
- 쿠버네티스 어노테이션을 사용하여 임의의 비-식별 메타데이터를 오브젝트에 첨부할 수 있다.
- 도구 및 라이브러리와 같은 클라이언트는 이 메타데이터를 검색할 수 있다.

### 오브젝트에 메타데이터 첨부
- 레이블이나 어노테이션을 사용하여 쿠버네티스 오브젝트에 메타데이터를 첨부할 수 있다. 레이블을 사용하여 오브젝트를 선택하고, 특정 조건을 만족하는 오브젝트 컬렉션을 찾을 수 있다. 반면에 어노테이션은 오브젝트를 식별하고 선택하는데 사용되지 않는다. 
- 어노테이션의 메타데이터는 작거나 크고, 구조적이거나 구조적이지 않을 수 있으며, 레이블에서 허용되지 않는 문자를 포함할 수 있다.

~~~yaml
metadata:   
  labels:
    l-key1: l-value1
    l-key2: l-value2
  annotaions:
    a-key1: a-value1
    a-key2: a-value2
~~~

- 사용 사례
    - 빌드 버전, 이미지 정보, 타임스탬프, Git 커밋 해쉬 등 빌드 관련 정보.
    - 해당 리소스 담당자의 연락처나 팀 이름.
    - kubectl apply가 사용하는 정보 (매우 긴 JSON 데이터)
    - Ingress 컨트롤러나 서비스 매쉬 (Istio 등)가 참고하는 특별한 동작 설정 값


## 필드 셀렉터
- 필드 셀렉터는 한 개 이상의 리소스 필드 값에 따라 쿠버네티스 리소스를 선택하기 위해 사용된다.
- 필드 셀렉터 쿼리 예시
    - `metadata.name=my-service`
    - `metadata.namespacae!=default`
    - `status.phase=Pending`
    - `kubectl get pods --field-selector status.phase=Running`


### 사용 가능한 필드
- 사용 가능한 필드는 쿠버네티스의 리소스 종류에 따라서 다르다. 모든 리소스 종류는 `metadata.name`과 `metadata.namespace` 필드 셀렉터를 사용할 수 있다.

### 사용 가능한 연산자
- 필드 셀렉터에서 `=`, `==`, `!=` 연산자를 사용할 수 있다.

### 연계되는 셀렉터
- 레이블을 비롯한 다른 셀렉터처럼, 쉼표로 구분되는 목록을 통해 필드 셀렉터를 연계해서 사용할 수 있다.